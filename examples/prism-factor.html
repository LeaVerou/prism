<h2>Comments</h2>
<pre> <code>! a comment</code> </pre>

<h2>Strings</h2>
<pre> <code>"a string" "\""</code> </pre>

<h2>Numbers</h2>
<pre><code>5 1/5 +9 -9 +1/5 -1/5 23+1/5 -23-1/5 23-1/5 ! last one = word

0.01 0e0 3E4 3e-4 3E-4 030 0xd 0o30 0b1100
-0 -0.01 -0e0 -3E4 -3E-4 -030 -0xd -0o30 -0b1100

348756424956392657834385437598743583648756332457
-348756424956392657834385437598743583648756332457

NAN: 80000deadbeef</code></pre>

<h2>Sequences</h2>
<pre><code>{ 1 2 3 4 }
{ a b c d e f }
{ "a" "b" "c" }

{ { a b } { c d } }
H{ { a b } { c d } }
H{ { "a" "b" } { "c" "d" } }
V{ 1 2 3 4 }
V{ "1" "2" "3" "4" }
BV{ 1 2 3 4 }</code></pre>

<h2>Colon parsing words</h2>
<pre><code>: a ( -- ) ;
:: ;
USING: a b c ;
USE: a
IN: a.b
CHAR: a</code></pre>

<h2>Some builtins</h2>
<pre><code>and not with map filter</code></pre>

<h2>Full example</h2>
<pre><code>USING: accessors arrays assocs combinators
combinators.short-circuit effects io kernel sequences
sequences.deep splitting strings vocabs words ;
IN: prism

: make-prism-syntax ( syntax-vocab -- seq )
 	vocab-words [
		dup name>> ">>" = [ drop t ] [
			{
				[ "delimiter" word-prop ]
				[ name>> last { CHAR: : CHAR: { CHAR: [ CHAR: ( CHAR: ) CHAR: ? CHAR: " } member? ]
				[ name>> { "t" "f" } member? ]
			} 1|| not
		] if
	] filter ;

: combinator? ( word -- ? )
	[ "declared-effect" word-prop in>> flatten
		[
			[ effect? ] [ { "quots" "quot" } member? ] bi or
		] any?
	] [
		"help" word-prop ?first flatten [ dup word? [ name>> ] when "quot" swap subseq? ] any?
	] bi or ;

: classify ( vocab-spec -- seq )
	vocab-words [
		dup {
			{ [ dup combinator? ] [ drop "combinator" ] }
			{ [ dup "macro" word-prop ] [ drop "macro" ] }
			[ drop "ordinary" ]
		} cond 2array
	] map ;

: print-strings ( strs -- )
	[ name>> "'" dup surround ] map ", " join print ;

: combinators. ( vocab-spec -- )
	classify [ nip "combinator" = ] assoc-filter keys print-strings ;

: ordinaries. ( vocab-spec -- )
	classify [ nip "ordinary" = ] assoc-filter keys print-strings ;

: macros. ( vocab-spec -- )
	classify [ nip "macro" = ] assoc-filter keys print-strings ;</code></pre>
