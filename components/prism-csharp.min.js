Prism.languages.csharp=Prism.languages.extend("clike",{keyword:/\b(?:abstract|add|alias|as|ascending|async|await|base|bool|break|byte|case|catch|char|checked|class|const|continue|decimal|default|delegate|descending|do|double|dynamic|else|enum|event|explicit|extern|false|finally|fixed|float|for|foreach|from|get|global|goto|group|if|implicit|in|int|interface|internal|into|is|join|let|lock|long|nameof|namespace|new|null|object|operator|orderby|out|override|params|partial|private|protected|public|readonly|ref|remove|return|sbyte|sealed|select|set|short|sizeof|stackalloc|static|string|struct|switch|this|throw|true|try|typeof|uint|ulong|unchecked|unsafe|ushort|using|value|var|virtual|void|volatile|where|while|yield)\b/,string:[{pattern:/@("|')(?:\1\1|\\[\s\S]|(?!\1)[^\\])*\1/,greedy:!0},{pattern:/("|')(?:\\.|(?!\1)[^\\\r\n])*?\1/,greedy:!0}],"class-name":[{pattern:/((?:^|\W)\[)[A-Z]\w*(?:\.\w+)*\b/,lookbehind:!0,inside:{punctuation:/\./}},{pattern:/(\b(?:class|enum|interface|struct)\s+)[A-Z]\w*(?:\.\w+)*(?:<[^\r\n=;{]+?>(?:\.\w+)*)?/,lookbehind:!0,inside:{punctuation:/[<>(),.:[\]]/}},{pattern:/(catch\s+\()[A-Z]\w*(?:\.\w+)*\b/,lookbehind:!0,inside:{punctuation:/\./}},{pattern:/(\bwhere\s+)[A-Z]\w*\b/,lookbehind:!0}],number:/(?:\b0(?:x[\da-f_]*[\da-f]|b[01_]*[01])|\B\.\d+|\b\d+(?:_+\d+)*\.?\d*)(?:ul|[flu])?\b/i}),Prism.languages.insertBefore("csharp","class-name",{"type-expression":{pattern:/(\b(?:default|typeof)\(\s*)[A-Z]\w*(?:\.\w+)*(?:<[^\r\n=;{]+?>(?:\.\w+)*)?(?=\s*\))/,lookbehind:!0,inside:{keyword:Prism.languages.csharp.keyword,"class-name":{pattern:/\b[A-Z]\w*(?:\.\w+)*\b/,inside:{punctuation:/\./}},punctuation:/[<>(),.:[\]]/}}}),Prism.languages.insertBefore("csharp","class-name",{"constructor-invocation":{pattern:/(\bnew\s+)[A-Z]\w*(?:\.\w+)*(?:<[^\r\n=;{]+?>(?:\.\w+)*)?\s*(?=[[({])/,lookbehind:!0,inside:Prism.languages.csharp["type-expression"].inside},"return-type":{pattern:/\b[A-Z]\w*(?:\.\w+)*(?:<[^\r\n=;{]+?>(?:\.\w+)*)?(?:\[\s*(,\s*)*\])?(?=\s+(?:[A-Z]\w*\.)?(?:\w+(?:\s*<[^\r\n=;{]+?>)?\s*(?:[({]|=>)|this\s*\[))/,inside:Prism.languages.csharp["type-expression"].inside},"generic-method":{pattern:/\w+\s*<[^\r\n=;{)]+?>\s*(?=\()/,inside:{"function":/^\w+/,"class-name":{pattern:/\b[A-Z]\w*(?:\.\w+)*\b/,inside:{punctuation:/\./}},keyword:Prism.languages.csharp.keyword,punctuation:/[<>(),.:[\]]/}},"type-list":{pattern:/(\b(?:class|interface|struct|enum)\s+\w*(?:\.\w+)*(<[^\r\n=;{]+?>)?(?:\.\w+)*\s*:\s*|\bwhere\s+\w+\s*:\s*)(?:\w+(?:<[^\r\n=;{]+?>)?(?:\s*,)?\s*?)+(?=\s*(?:where|[{;]|=>))/,lookbehind:!0,inside:Prism.languages.csharp["type-expression"].inside},"identifier-type":{pattern:/\b[A-Z]\w*(?:\.\w+)*(?:<[^\r\n=;{]+?>(?:\.\w+)*)?(?:\s*\[\s*(?:,\s*)*\])?(?=\s+\w+(?:\s*[=,;:{)]|\s+in))/,inside:Prism.languages.csharp["type-expression"].inside},preprocessor:{pattern:/(^\s*)#.*/m,lookbehind:!0,alias:"property",inside:{directive:{pattern:/(\s*#)\b(?:define|elif|else|endif|endregion|error|if|line|pragma|region|undef|warning)\b/,lookbehind:!0,alias:"keyword"}}}}),Prism.languages.dotnet=Prism.languages.csharp;